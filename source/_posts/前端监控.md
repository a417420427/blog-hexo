---
title: 前端监控
tags: js 日志  前端监控
categories: javascript
---

## 数据分析

### 范围

#### 数据采集

1. 异常

- 脚本错误 -

  ```js
  // https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror
  try {} catch(){
    // catch 中的错误 全局 error 事件可以捕捉到
    // catch 无法捕捉自身错误
  }
  // 比 window.onerror 先触发
  window.addEventListener("error", error => {
    // ErrorEvent
    console.log('window.addEventListener', error)
  });

  /**
   * @param {string} message 错误信息（字符串）。可用于HTML onerror=""处理程序中的event。
   * @param {string} source 发生错误的脚本URL（字符串）
   * @param {number} lineno 发生错误的行号（数字）
   * @param {number} colno 发生错误的列号（数字）
   * @param {ErrorEvent.error} error
  */
  window.onerror = (message, source, lineno, colno, error) => {
    console.log('window.onerror', [message, source, lineno, colno, error])
  };

  window.addEventListener("unhandledrejection", error => {
    console.log('unhandledrejection', errorp)
  });
  ```

- 接口异常 - request catch
- 资源异常 - img.onerror

```html
<!-- 
    资源加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数 
    这些 error 事件不会向上冒泡到 window
  -->
<img src="https://a.b.c.d/sample.png" onerror="alert(arguments[0])" />
```

- 白屏

- Crash -

2. 流畅性

- 动画流畅性 requestAnimationFrame

- 页面加载速度
  [屏幕性能部分指标](http://94.74.88.178/assets/images/performance-timeline.png)

```js
/**
 *
 * 屏幕性能指标
 * 1. FP (First Paint) 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点。 PerformanceObserver
 * 2. FCP (First Contentful Paint) 首次内容绘制 标记浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 甚至 元素。  检测方法 PerformanceObserver
 * 3. DCL (DomContentloaded) 当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的完成加载。检测方法 DOMContentLoaded
 * 4. LCP (Largest Contentful Paint) 最大内容渲染 衡量viewport内可见的最大内容元素的渲染时间。元素包括img、video、div及其他块级元素。检测方法  PerformanceObserver
 * 5. FMP(First Meaningful Paint) 首次有效绘制
 * 6. L (onLoad) 页面的onLoad时的时间点。当依赖的资源, 全部加载完毕之后才会触发。 检测方法 onLoad
 *
 * 7. TTI (Time to Interactive) 可交互时间 用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点。
 * 8. TBT (Total Blocking Time) 页面阻塞总时长
 * 9. FID (First Input Delay) 首次输入延迟 FID (First Input Delay) 首次输入延迟: 指标衡量的是从用户首次与您的网站进行交互（即当他们单击链接，点击按钮等）到浏览器实际能够访问之间的时间
 * 10. CLS (Cumulative Layout Shift) 累积布局偏移   一个元素初始时和其hidden之间的任何时间如果元素偏移了, 则会被计算进去
 * 11. SI (Speed Index) 显示页面可见部分的显示速度, 单位是时间
 */

function pageSpeed() {
  const startTime = getCurrentTime();
  const timeArray = [];

  window.addEventListener("DOMContentLoaded", e => {
    timeArray.push({
      name: "DOMContentLoaded(DCL)",
      time: getCurrentTime()
    });
  });
  window.addEventListener("load",  e => {
    timeArray.push({
      name: "onLoad(L)",
      time: getCurrentTime()
    });
  };

  function showPaintTimings() {
    let performance = window.performance;
    let performanceEntries = performance.getEntriesByType("paint");
    performanceEntries.forEach((performanceEntry, i, entries) => {
      timeArray.push({
        name: performanceEntry.name,
        time: startTime + performanceEntry.startTime
      });
    });
  }

  setTimeout(() => {
    showPaintTimings();
    timeArray.sort((a, b) => a.time - b.time);
    timeArray.forEach(t => {
      /**
       * 输出
       * DOMContentLoaded(DCL)---1655104428996
       * first-paint---1655104429107.6
       * first-contentful-paint---1655104429163.1
       * onLoad(L)---1655104431285
       */
      console.log(t.name + "---" + t.time);
    });
  }, 5000);
}

function getCurrentTime() {
  return new Date().getTime();
}
```

- 响应速度
- 滚动流畅性

```js
const performanceObserver = new PerformanceObserver(list => {
  list.getEntries().forEach(entry => {
    console.log(entry); // 上报
  });
});
// resource（资源加载耗时）、mark（时间点）、measure（时间段）
// touchscrolllatency(滚动) 只有UC系内核的阿里系APP（如手淘、猫客）支持。。。
// longtask 哪些任务执行耗费了 50 毫秒或更多时间
//
performanceObserver.observe({
  entryTypes: ["resource", "mark", "measure", "touchscrolllatency", "longtask"]
});

performance.mark("registered-observer");

function measureClick() {
  performance.measure("#app clicked");
}

doucument.querySelector("#app").addEventListener("click", measureClick);
```

- 卡顿 主线程持续执行某一个任务的耗时大于 50ms
  [APS 项目耗时超过 50ms 任务列表](http://94.74.88.178/assets/images/aps_long_task_list.png)

* vue 捕获错误

```js
Vue.config.errorHandler = function VueErrorHandler(error, vm, info) {};
```

- react 捕获错误

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  componentDidCatch(error, info) {
    this.setState({ hasError: true });
    // 上报错误
    reportError(error, info);
  }
  render() {
    if (this.state.hasError) {
      return <h1>页面错误</h1>;
    }
    return this.props.children;
  }
}
// 对 函数组件 生效
<ErrorBoundary>
  <App />
</ErrorBoundary>;
```

3. 用户行为回放

- Api 请求，鼠标事件，键盘事件，路由跳转，error

#### 信息上报

1. 方式 图片,fetch/xhr,Navigator.sendBeacon()

### 日志的解析、处理、存储，到分析、告警功能实现

1. 后端提供日志上报接口给到采集 SDK
2. 后端应用接收到的日志后处理成可被实时流计算处理的流式数据

## 脚本编写

```js
export const TRACKER_LOGGER_KEY = "TRACKER_LOGGER_KEY";

/** 指标 */
export const Indicator = {
  /** 直接可监听 */
  script: "script",
  request: "request",
  assets: "assets",
  /** 流畅性/性能分析 - 页面加载/交互 过程上报 */
  fluency: "fluency",
  /** 用户行为分析 通过各类事件手动上报 */
  actions: "actions"
};

/**
 * @typedef Tracker
 * @property {object} Tracker.Indicator
 * @property {function} Tracker.track
 *
 * @returns {Tracker}
 */
export function Tracker() {
  /** 发送事件 */
  function track(options) {
    /** 保存捕获的错误信息 */
    loggerCapture(options);

    console.log(options);
  }

  return {
    track,
    Indicator
  };
}

/** 模拟数据收集 */
function loggerCapture(logger) {
  const logs = getLoggers();

  logs.push(getLogger(logger));
  localStorage.setItem(TRACKER_LOGGER_KEY, JSON.stringify(logs));
}

/** 模拟请求返回数据 */
export function getLoggers() {
  let logs = localStorage.getItem(TRACKER_LOGGER_KEY);
  try {
    logs = JSON.parse(logs) || [];
  } catch (_) {
    logs = [];
  }
  return logs;
}

/** 错误信息数据分析 */
function getLogger(logger) {
  /** 基本错误信息 */
  const commonJsTrack = {
    os: getOS(),
    userAgent: getBrowser(),
    url: location.href,
    timestamp: Date.now(),
    type: logger.type || Indicator.script
  };

  return {
    ...commonJsTrack,
    type: logger.type,
    ...logger.error
  };
}

export const tracker = new Tracker();

function getOS() {
  let sUserAgent = navigator.userAgent;
  let isWin = navigator.platform == "Win32" || navigator.platform == "Windows";
  let isMac =
    navigator.platform == "Mac68K" ||
    navigator.platform == "MacPPC" ||
    navigator.platform == "Macintosh" ||
    navigator.platform == "MacIntel";
  if (isMac) return "Mac";
  let isUnix = navigator.platform == "X11" && !isWin && !isMac;
  if (isUnix) return "Unix";
  let isLinux = String(navigator.platform).indexOf("Linux") > -1;
  if (isLinux) return "Linux";
  if (isWin) {
    let isWin2K =
      sUserAgent.indexOf("Windows NT 5.0") > -1 ||
      sUserAgent.indexOf("Windows 2000") > -1;
    if (isWin2K) return "Win2000";
    let isWinXP =
      sUserAgent.indexOf("Windows NT 5.1") > -1 ||
      sUserAgent.indexOf("Windows XP") > -1;
    if (isWinXP) return "WinXP";
    let isWin2003 =
      sUserAgent.indexOf("Windows NT 5.2") > -1 ||
      sUserAgent.indexOf("Windows 2003") > -1;
    if (isWin2003) return "Win2003";
    let isWinVista =
      sUserAgent.indexOf("Windows NT 6.0") > -1 ||
      sUserAgent.indexOf("Windows Vista") > -1;
    if (isWinVista) return "WinVista";
    let isWin7 =
      sUserAgent.indexOf("Windows NT 6.1") > -1 ||
      sUserAgent.indexOf("Windows 7") > -1;
    if (isWin7) return "Win7";
    let isWin10 =
      sUserAgent.indexOf("Windows NT 10") > -1 ||
      sUserAgent.indexOf("Windows 10") > -1;
    if (isWin10) return "Win10";
  }
  return "other";
}

function getBrowser() {
  let browser = {};
  let userAgent = navigator.userAgent.toLowerCase();
  let s;
  (s = userAgent.match(/msie ([\d.]+)/))
    ? (browser.ie = s[1])
    : (s = userAgent.match(/firefox\/([\d.]+)/))
    ? (browser.firefox = s[1])
    : (s = userAgent.match(/chrome\/([\d.]+)/))
    ? (browser.chrome = s[1])
    : (s = userAgent.match(/opera.([\d.]+)/))
    ? (browser.opera = s[1])
    : (s = userAgent.match(/version\/([\d.]+).*safari/))
    ? (browser.safari = s[1])
    : 0;
  let version = "";
  if (browser.ie) {
    version = "IE " + browser.ie;
  } else {
    if (browser.firefox) {
      version = "Firefox";
      // version = 'firefox ' + browser.firefox;
    } else {
      if (browser.chrome) {
        version = "Chrome";
        // version = 'chrome ' + browser.chrome;
      } else {
        if (browser.opera) {
          version = "Opera";
          // version = 'opera ' + browser.opera;
        } else {
          if (browser.safari) {
            version = "Safari";
            // version = 'safari ' + browser.safari;
          } else {
            version = "未知浏览器";
          }
        }
      }
    }
  }
  console.log(version, "00-0");
  return version;
}

export function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
```
