---
title: 节流和防抖
tags: lodash debounce
categories: javascript
---

## 定义

- 防抖(debounce): 触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。
- 节流(throttle): 高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行效率。

## 实现

- 基础版

```js
function debounce(fn, timing) {
  let timer;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn();
    }, timing);
  };
}

function throttle(fn, timing) {
  let isFnExcuted;
  return function () {
    if (isFnExcuted) return;
    isFnExcuted = true;
    fn();
    setTimeout(() => {
      isFnExcuted = false;
    }, timing);
  };
}
```

- 保留原函数 this 指针

```js
function debounce(fn, timing) {
  let timer;
  return function (...args) {
    const _this = this;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(_this, args);
    }, timing);
  };
}

function throttle(fn, timing) {
  let isFnExcuted;
  return function (...args) {
    const _this = this;
    if (isFnExcuted) return;
    isFnExcuted = true;
    fn.apply(_this, args);
    setTimeout(() => {
      isFnExcuted = false;
    }, timing);
  };
}
```

- 异步函数

```js
function getTimeStamp() {
  return Date.now();
}
const controlledSleep = {
  timer: null,
  sleep: function (time) {
    const _this = this;
    return new Promise((resolve) => {
      _this.timer = setTimeout(() => resolve(), time);
    });
  },
  cancel() {
    clearTimeout(this.timer);
    this.timer = null;
  },
};
function debounce(fn, timing) {
  let timer;
  return async function (...args) {
    const _this = this;
    clearTimeout(timer);
    controlledSleep.cancel();
    await controlledSleep.sleep(timing);
    timer = controlledSleep.timer;
    let startTime = getTimeStamp();
    await fn.apply(_this, args);
  };
}
```

- 延时前后是否触发(leading, trailing), 设置最大等待时间 ，这里情况比较复杂，暂时不单独讨论， 后面有时间再做详细的实现
